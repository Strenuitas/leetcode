# 思路
遍历法，从头结点开始遍历，每个遍历到的结点都要从此位置再次遍历到结尾找到与他相同的元素并删掉。找到重复的结点然后删除。不过这样时间复杂度On^2.

```
public ListNode deleteDuplicates(ListNode head){
        ListNode temp = head;
        while (temp != null){
            ListNode temp1 = temp.next;
            while (temp1 != null){
                if(temp1.val == temp.val){
                    temp.next = temp1.next;
                }
                temp1 = temp1.next;
            }
            temp = temp.next;
        }
        return head;
    }
```

# 思路2
因为链表为有序，因此与某个节点数据相同的结点只能与之相邻,如果相邻结点元素相同，那么删掉后里面的结点。






初版  
```
public ListNode deleteDuplicates(ListNode head) {
        //有序链表，即相同元素值结点是相邻
        ListNode cur = head;
        while (cur != null && cur.next != null){
            if(cur.val == cur.next.val){
                cur.next = cur.next.next;
            }else {
                cur = cur.next;
            }
        }
        return head;
    }
```
  
改进版  
使用cur来记录当前节点会更清晰。      
```
   public ListNode deleteDuplicates(ListNode head) {
        //有序链表，即相同元素值结点是相邻
        ListNode cur = head;
        while (cur != null && cur.next != null){
            if(cur.val == cur.next.val){
                cur.next = cur.next.next;
            }else {
                cur = cur.next;
            }
        }
        return head;
    }
```
