
# 思路
使用双指针遍历，比较两个指针对应结点的值大小，哪个小，开始是选取为头结点，然后转到下一个结点再与上一个进行比较，然后链接到小的结点。这样一直到有个链表遍历完，然后接上没有遍历完的链表即可。既然两个进行比较，那么小的那个就要接到某个结点的后面，把这个要接的新的结点的前一部分叫做前驱prev，prev是一直在变的，  
因此我们要设置一个开始的节点也就是newHead或者说是dummy记录最后得到的链表。一开始newHead==prev，然后后面prev一直接新的结点--接完后自己还要变成新的要插入的结点的前驱，等于说是后插法，一直插入到新的链表的后面，直到一个链表插完，然后prev前驱接另一个链表的剩余部分即可。

```
public ListNode mergeTwoLists(ListNode headA,ListNode headB){
        ListNode tempA = headA;
        ListNode tempB = headB;
        //既然最后要记录新的链表头，索性再添加一个哑结点，
        ListNode dummy = new ListNode(-1);
        //而且这时候我们要一直更新新的结点是否为a还是b的结点，所以就要有一个前驱
        ListNode prev = dummy;
        while (tempA != null && tempB != null){
            if(tempA.val < tempB.val){
                prev.next = tempA;
                tempA = tempA.next;
            }else {
                prev.next = tempB;
                tempB = tempB.next;
            }
            prev = prev.next;
        }
        prev.next = tempA == null ? tempB : tempA;
        return dummy.next;
    }
```
