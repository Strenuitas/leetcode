# 思路


# 分为两种情况：
1 分组数>=链表节点数字，  直接每个结点对应一个位置，多于的填充null
2 分组数<链表节点数字,每个位置的结点数=结点总数/k，同时看余数是多少，余数多1个 那就第一个再加一个结点，多两个，第二个再加一个，以此类推
```
public static ListNode[] getKLists(ListNode head,int k){
        ListNode temp = head;
        ListNode[] result = new ListNode[k];
        if(head == null){
            return result;
        }
        int count = 0;
        while (temp != null){
            count++;
            temp = temp.next;
        }
        if(k >= count){
            ListNode temp1 = head;
            int i = 1;
            while (i <= k){
                if(i <= count){
                    ListNode next = temp1.next;
                    result[i-1] = temp1;
                    temp1.next = null;
                    temp1 = next;
                }else {
                    result[i-1] = null;
                }
                i++;
            }
        }else {
            ListNode temp2 = head;
            int newCount = count / k;
            int remainder = count % k;
            for (int i = 1; i <= k; i++) {
                ListNode dummy = new ListNode(-1);
                ListNode dummyTemp = dummy;
                int realCount = newCount;
                if(remainder >= i) {
                    realCount++;
                }
                for(int j = 1; j<= realCount; j++){
                    if(temp2 != null){
                        ListNode next = temp2.next;
                        dummyTemp.next = temp2;
                        temp2.next = null;
                        temp2 = next;
                        dummyTemp = dummyTemp.next;
                    }
                }
                result[i-1] = dummy.next;
            }
        }
        return result;
    }
```
# 放入到同一个循环中
```
public static ListNode[] splitListToParts(ListNode head,int k){
        int count = 0;
        ListNode temp = head;
        ListNode[] result = new ListNode[k];
        while (temp != null){
            count++;
            temp = temp.next;
        }
        int quotient = count / k;
        int remainder = count % k;

        ListNode cur = head;
        for(int i = 0; i < k && cur != null;i++){
            int partSize = quotient + (i < remainder ? 1 : 0);
            result[i] = cur;
            for (int j = 1; j <= partSize;j++){
                cur = cur.next;
            }
            ListNode next = cur.next;
            cur.next = null;
            cur = next;
        }
        return result;
    }
