# 思路


# 分为两种情况：
1 分组数>=链表节点数字，  直接每个结点对应一个位置，多于的填充null
2 分组数<链表节点数字,每个位置的结点数=结点总数/k，同时看余数是多少，余数多1个 那就第一个再加一个结点，多两个，第二个再加一个，以此类推
```
public static ListNode[] getKLists(ListNode head,int k){
        ListNode temp = head;
        ListNode[] result = new ListNode[k];
        if(head == null){
            return result;
        }
        int count = 0;
        while (temp != null){
            count++;
            temp = temp.next;
        }
        ArrayList<ListNode> list = new ArrayList<ListNode>();
        if(k >= count){
            ListNode temp1 = head;
            int i = 1;
            while (i <= k){
                if(i <= count){
                    list.add(temp1);
                    temp1 = temp1.next;
                }else {
                    list.add(null);
                }
            }
            i++;
        }else {
            ListNode temp2 = head;
            int newCount = count / k;
            int remainder = count % k;
            for (int i = 1; i <= k; i++) {
                ListNode dummy = new ListNode(-1);
                ListNode dummyTemp = dummy;
                int realCount = newCount;
                if(remainder >= i) {
                    realCount++;
                }
                for(int j = 1; j<= realCount; j++){
                    if(temp2.next != null){
                        ListNode next = temp2.next;
                        dummyTemp.next = temp2;
                        temp2.next = null;
                        temp2 = next;
                        dummyTemp = dummyTemp.next;
                    }
                }
                list.add(dummy.next);
            }
        }
        for (int i = 0; i < list.size(); i++) {
            result[i] = list.get(i);
        }
        return result;
    }
```
# 这种空间复杂度太大了
