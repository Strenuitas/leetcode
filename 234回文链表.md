# 思路

链表转化为数组，使用双指针，前指针遍历，后指针同步遍历，如果相同则继续，不同则不回文，遍历条件 l < r 
反转链表，获取新的链表 两者同步遍历 比较。 
反转链表：  将链表复制到数组中，使用ArrayList,因为不知道链表长度,所以使用ArrayList.然后放到数组里面判断回文即可。  ArrayList的方法 toArray(new T[a])，若是不知道要传入的
数组的长度a为0，ArrayList会自动创建一个长度合适的数组，但是只能创建引用数据类型的数组，不能创建基本数据类型的。或者使用流式传输即   
```
list.stream.mapToInt(Integer::intValue).toArray();
//或者直接数组,双指针
int front = 0;
int back = list.size() -1;
while(front < back){
  if(list.get(front) != list.get(back)){
    return false;
  }
}
return true;
```

## 快慢指针
设置一快一慢个指针指向头结点，然后快走两步，慢走一步如果链表长度为奇数，那么要走的路径是偶路径，即当快指针到头的时候即fast.next == null, 也就是 n-1 / 2 = slow 即 n/2下取整 也就是走了slow步数也就是 到了中间的位置  
若链表长度为偶数，即要走的路径为奇路径，也就是前后分组相等，即要把slow控制在n/2 -1  这样就能刚好把slow控制在前半部分的末尾，和奇数链表适配一样的算法了。  然后slow.next即为后边链表头，然后反转和前半部分一起遍历，后半部分在奇数下会少1，因此以后半部分为遍历结束条件。


```

public static void main(String[] args) {
        ListNode h = buildList(1,2,2,1);
        SolutionRev1 s = new SolutionRev1();
        boolean result = s.isPalindrome(h);
        System.out.println(result);
    }

    //构造链表
    public static ListNode buildList(int... vals){
        ListNode dummy = new ListNode(0);
        ListNode curr = dummy;
        for (int val : vals) {
            curr.next = new ListNode(val);
            curr = curr.next;
        }
        return dummy.next;
    }
```
