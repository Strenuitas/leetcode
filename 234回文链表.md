# 思路

使用双指针，前指针遍历，后指针同步遍历，如果相同则继续，不同则不回文，遍历条件 l < r 
反转链表，获取新的链表 两者同步遍历 比较。 
反转链表：  将链表复制到数组中，使用ArrayList,因为不知道链表长度,所以使用ArrayList.然后放到数组里面判断回文即可。  ArrayList的方法 toArray(new T[a])，若是不知道要传入的
数组的长度a为0，ArrayList会自动创建一个长度合适的数组，但是只能创建引用数据类型的数组，不能创建基本数据类型的。或者使用流式传输即   
```
list.stream.mapToInt(Integer::intValue).toArray();
//或者直接数组,双指针
int front = 0;
int back = list.size() -1;
while(front < back){
  if(list.get(front) != list.get(back)){
    return false;
  }
}
return true;
```

## 快慢指针
设置一快一慢个指针指向头结点，然后快走两步，慢走一步如果链表长度为奇数，那么要走的路径是偶路径，即当快指针到头的时候即fast.next == null, 也就是 n-1 / 2 = slow 即 n/2下取整 也就是走了slow步数也就是 到了中间的位置
                                                    若链表长度为偶数，即要走的路径为偶路径，也就是前后分组相等，即要把slow控制在n/2 -1  这样就能刚好把slow控制在前半部分的末尾，和奇数链表适配一样的算法了。


# 
