思路：链表 7-2-3-4  得出来数字 7234  加上 3-3-1  331 得到 7234+331=7565,要放到新链表 7-5-6-6。  不使用int long 存储，因为都有限制，使用链表存储，链头代表高位，链尾代表低位，相加的话肯定是低位相加进位，依次再进高位，不难联想到链栈，栈顶存链尾，栈底存链头，刚好也弥补了我们获取不到链尾也就是拿不到个位。
如果是一般的思路肯定是化成整数然后相加，但实际上数字如果够大的话，你化成什么类型的数字都不行，因此仍然是按位相加，最为妥当。

选择三段循环，先是两个栈都有值的时候,然后一个栈没有值，同样要带着从第一个循环带出来的carry进位参与到之后的循环，最后还要判断carry是否为1，如果为1再加上一个新的结点。
```
public  ListNode addTwoListNode(ListNode h1, ListNode h2) {
        Deque<ListNode> stack1 = new ArrayDeque<>();
        Deque<ListNode> stack2 = new ArrayDeque<>();
        while (h1 != null){
            stack1.push(h1);
            h1 = h1.next;
        }
        while (h2!= null){
            stack2.push(h2);
            h2 = h2.next;
        }
        ListNode resultHead = new ListNode(-1);
        //这样队列队头就是链头，队尾就是链尾也就是个位
        int carry = 0;
        while (stack1.size() != 0 && stack2.size() != 0){
            int sum = stack1.pop().val + stack2.pop().val + carry;
            carry = sum / 10;
            ListNode cur = new ListNode(sum % 10,resultHead.next);
            resultHead.next = cur;
        }
        while (stack1.size() != 0){
            int sum = stack1.pop().val + carry;
            carry = sum /10;
            ListNode cur = new ListNode(sum % 10,resultHead.next);
            resultHead.next = cur;
        }
        while (stack2.size() != 0){
            int sum = stack2.pop().val + carry;
            carry = sum / 10;
            ListNode cur = new ListNode(sum % 10,resultHead.next);
            resultHead.next = cur;
        }
        //最后还可能有个carry
        if(carry != 0){
            ListNode cur = new ListNode(carry,resultHead.next);
            resultHead.next = cur;
        }
        return resultHead.next;
    }
```

# 改进版，一段循环就结束
```
public  ListNode addTwoListNode1(ListNode h1, ListNode h2) {
        Deque<ListNode> stack1 = new ArrayDeque<>();
        Deque<ListNode> stack2 = new ArrayDeque<>();

        while (h1 != null){
            stack1.push(h1);
            h1 = h1.next;
        }
        while (h2 != null){
            stack2.push(h2);
            h2 = h2.next;
        }
        int carry = 0;
        ListNode node = null;
        while (!stack1.isEmpty() || !stack2.isEmpty() || carry != 0){
            int val1 = stack1.isEmpty() ? 0 : stack1.pop().val;
            int val2 =  stack2.isEmpty() ? 0 : stack2.pop().val;
            int sum = val1 + val2 + carry;
            carry = sum / 10;
            ListNode cur = new ListNode(sum % 10, node);
            node = cur;
        }
        return node;
    }
```
